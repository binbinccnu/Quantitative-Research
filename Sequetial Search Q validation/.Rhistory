tmp <- rowSums(XX*log(tmp) + (1-XX)*log(1-tmp)) + lprior
tmp <- exp(tmp)
post_prior[i,] <- t(tmp/sum(tmp))
proc.time()-pmt
.015*1000
XX <- matrix(1,2^K,1) %*% as.matrix(response[i,])
XX
temp
tmp
J
tmp <- matrix(0,2^K,J)
XX <- matrix(1,2^K,1) %*% as.matrix(response[i,])
tmp <- matrix(0,2^K,J)
tmp
est
eta[cl,j]
est[j,]
tmp
a=est[j,]
j
j=1
a=est[1,]
a
est
matrix(1,2^K,1)
as.matrix(response[i,])
XX <- matrix(1,2^K,1) %*% as.matrix(response[i,])
tmp <- matrix(0,2^K,J)
for (j in 1:J) {
for (cl in 1:2^K) {
tmp[cl,j] <- est[j,eta[cl,j]+1]
}
}
XX*log(tmp)
View(XX)
View(XX)
View(tmp)
View(tmp)
for (j in 1:J) {
for (cl in 1:2^K) {
tmp[cl,j] <- est[j,eta[cl,j]+1]
}
}
response[i,]
View(XX)
XX*log(tmp)-response[i,]*log(tmp)
XX*log(tmp)
View(tmp)
XX*tmp
XX*tmp-temp
XX*tmp-tmp
XX*tmp-tmp*response[i,]
tmp*response[i,]
K <- ncol(Q)
N <- nrow(response)
J <- nrow(Q)
tmp0 <- matrix(0,2^K,J)
for (j in 1:J) {
for (cl in 1:2^K) {
tmp0[cl,j] <- est[j,eta[cl,j]+1]
}
}
for (i in 1:N) {
pmt=proc.time()
XX <- matrix(1,2^K,1) %*% as.matrix(response[i,])
tmp <- rowSums(XX*log(tmp0) + (1-XX)*log(1-tmp0)) + lprior
tmp <- exp(tmp)
post_prior[i,] <- t(tmp/sum(tmp))
proc.time()-pmt
}
post <- post_prior
post
rm(list=ls(all=TRUE))
path  <- '/Users/Aurora/Dropbox/CD/Sequetial Search'
#path <- 'D:/dropbox/CD/Sequetial Search'
Q        <- read.table(file=paste(path,'/Q_matrix_5.txt',sep='')) # original Q matrix
response <- read.table(file=paste(path,'/examinee_data.dat',sep=''))
eps <- .002
source(paste(path,'//sourceDir.R',sep=''))
sourceDir(paste(path,'/functions',sep=''))
alpha <- AlphaPermute(ncol(Q))
eta   <- Alphaeta(alpha,Q)
prior  <- matrix(1,2^ncol(Q),1)/2^ncol(Q)
lprior <- log(prior/sum(prior))
lprior[lprior==-Inf] <- -2.14748e+09
post_prior <- matrix(1,nrow(response),2^ncol(Q))
Iterate <- function(est,eta,lprior,post_prior,response,Q) {
J <- nrow(Q)
K <- ncol(Q)
it <- 0;
diff <- 1;
maxit <- 999
crit <- .001
est <- -1*matrix(1,nrow(Q),2^max(rowSums(Q)))
for (j in 1:J) {
Kj <- rowSums(Q[j,])
est[j,1:2^Kj] <- .2
est[j,2^Kj] <- .8
}
post <- Findpost(est,eta,lprior,post_prior,response,Q)
}
J <- nrow(Q)
K <- ncol(Q)
it <- 0;
diff <- 1;
maxit <- 999
crit <- .001
est <- -1*matrix(1,nrow(Q),2^max(rowSums(Q)))
for (j in 1:J) {
Kj <- rowSums(Q[j,])
est[j,1:2^Kj] <- .2
est[j,2^Kj] <- .8
}
post <- Findpost(est,eta,lprior,post_prior,response,Q)
K <- ncol(Q)
N <- nrow(response)
J <- nrow(Q)
tmp0 <- matrix(0,2^K,J)
for (j in 1:J) {
for (cl in 1:2^K) {
tmp0[cl,j] <- est[j,eta[cl,j]+1]
}
}
for (i in 1:N) {
pmt=proc.time()
XX <- matrix(1,2^K,1) %*% as.matrix(response[i,])
tmp <- rowSums(XX*log(tmp0) + (1-XX)*log(1-tmp0)) + lprior
tmp <- exp(tmp)
post_prior[i,] <- t(tmp/sum(tmp))
proc.time()-pmt
}
post_prior-post
sum(post_prior-post)
i
i=1
XX <- matrix(1,2^K,1) %*% as.matrix(response[i,])
View(XX)
response[i,]
a=XX*log(tmp0)
View(a)
b=apply(log(tmp0),1,func(x):x*response[i,])
b=apply(log(tmp0),1,fun(x):x*response[i,])
b=apply(log(tmp0),1,function(x):x*response[i,])
b=apply(log(tmp0),1,function(x) x*response[i,])
b
a-b
b=apply(log(tmp0),2,function(x) x*response[i,])
a-b
b
b=apply(log(tmp0),1,function(x) x*response[i,])
a-b''
a-t(b)
b
dim(b)
View(tmp0)
dim(response)
dim(log(tmp0))
size(tmp)
dim(tmp)
K <- ncol(Q)
N <- nrow(response)
J <- nrow(Q)
tmp0 <- matrix(0,2^K,J)
for (j in 1:J) {
for (cl in 1:2^K) {
tmp0[cl,j] <- est[j,eta[cl,j]+1]
}
}
tmp1 = log(tmp0)%*%response + log(1-tmp0)%*%(1-response)
tmp1 = exp(tmp1)
dim(response)
tmp1 = log(tmp0)%*%t(response) + log(1-tmp0)%*%t(1-response)
tmp1 = exp(tmp1)
View(tmp1)
for (i in 1:N) {
pmt=proc.time()
XX <- matrix(1,2^K,1) %*% as.matrix(response[i,])
tmp <- rowSums(XX*log(tmp0) + (1-XX)*log(1-tmp0)) #+ lprior
tmp <- exp(tmp)
cat(tmp)
post_prior[i,] <- t(tmp/sum(tmp))
proc.time()-pmt
}
dim(tmp1)
a = c()
for (i in 1:N) {
pmt=proc.time()
XX <- matrix(1,2^K,1) %*% as.matrix(response[i,])
tmp <- rowSums(XX*log(tmp0) + (1-XX)*log(1-tmp0)) #+ lprior
tmp <- exp(tmp)
a = cbind(a,tmp)
post_prior[i,] <- t(tmp/sum(tmp))
proc.time()-pmt
}
a
View(a)
dim(a)
dim(tmp)
dim(tmp1)
tmp1-a
sum(tmp1-a)
View(a)
(tmp1-a)[1,]
tmp1 = log(tmp0)%*%t(response) + log(1-tmp0)%*%t(1-response)
tmp1 = exp(tmp1)
post_prior1 = tmp1 + lprior
a = c()
for (i in 1:N) {
pmt=proc.time()
XX <- matrix(1,2^K,1) %*% as.matrix(response[i,])
tmp <- rowSums(XX*log(tmp0) + (1-XX)*log(1-tmp0)) + lprior
tmp <- exp(tmp)
a = cbind(a,tmp)
post_prior[i,] <- t(tmp/sum(tmp))
proc.time()-pmt
}
dim(tmp1)
lprior
tmp1
lprior
rep(lprior,2)
lprior[,rep(1,1000)]
tmp1 = log(tmp0)%*%t(response) + log(1-tmp0)%*%t(1-response)
tmp1 = exp(tmp1)
post_prior1 = tmp1 + lprior[,rep(1,1000)]
View(post_prior)
tmp1 = log(tmp0)%*%t(response) + log(1-tmp0)%*%t(1-response) + lprior[,rep(1,1000)]
tmp1 = exp(tmp1)
a = c()
for (i in 1:N) {
pmt=proc.time()
XX <- matrix(1,2^K,1) %*% as.matrix(response[i,])
tmp <- rowSums(XX*log(tmp0) + (1-XX)*log(1-tmp0)) + lprior
tmp <- exp(tmp)
a = cbind(a,tmp)
post_prior[i,] <- t(tmp/sum(tmp))
proc.time()-pmt
}
View(a)
View(tmp1)
sum(tmp1-a)
tmp1 = log(tmp0)%*%t(response) + log(1-tmp0)%*%t(1-response) + lprior[,rep(1,1000)]
tmp1 = exp(tmp1)
post_prior1 = tmp1 / colSums(tmp1)
View(post)
View(post_prior)
sum(post-post_prior)
sum(post-post_prior1)
dim(post)
dim(post_prior1)
View(post)
View(post_prior)
View(post_prior1)
post_prior1 = t(tmp1 / colSums(tmp1))
sum(post-post_prior1)
View(post)
post_prior1 = t(tmp1 / rowSums(tmp1))
View(post_prior1)
colSums(tmp1)
dim(tmp1)
tmp
tmp/sum(tmp)
tmp
colSums(tmp1)
rowSums(tmp1)
tmp
sum(tmp)
dim(tmp1)
tmp1[,1]/colSums(tmp1)[1]
View(post_prior)
tmp1 = log(tmp0)%*%t(response) + log(1-tmp0)%*%t(1-response) + lprior[,rep(1,N)]
tmp1 = exp(tmp1)
post_prior1 = t(tmp1 / colSums(tmp1)[rep(1,2^K),])
View(post_prior1)
colSums(tmp1)[rep(1,2^K),]
tmp2 = colSums(tmp1)
tmp2[rep(1,2^K),]
rep(1,2^K)
tmp2
tmp2 = as.matrix(colSums(tmp1))
tmp2[rep(1,2^K),]
tmp2
tmp2 = t(colSums(tmp1))
tmp2[rep(1,2^K),]
tmp1 = log(tmp0)%*%t(response) + log(1-tmp0)%*%t(1-response) + lprior[,rep(1,N)]
tmp1 = exp(tmp1)
tmp2 = t(colSums(tmp1))
post_prior1 = t(tmp1 / tmp2[rep(1,2^K),])
View(post_prior1)
sum(post_prior1-post)
post_prior1-post
source('~/.active-rstudio-document')
a=Findpost(est,eta,lprior,post_prior,response,Q)
sum(a-post)
a-post
rm(list=ls(all=TRUE))
path  <- '/Users/Aurora/Dropbox/CD/Sequetial Search'
#path <- 'D:/dropbox/CD/Sequetial Search'
Q        <- read.table(file=paste(path,'/Q_matrix_5.txt',sep='')) # original Q matrix
response <- read.table(file=paste(path,'/examinee_data.dat',sep=''))
eps <- .002
source(paste(path,'//sourceDir.R',sep=''))
sourceDir(paste(path,'/functions',sep=''))
alpha <- AlphaPermute(ncol(Q))
eta   <- Alphaeta(alpha,Q)
prior  <- matrix(1,2^ncol(Q),1)/2^ncol(Q)
lprior <- log(prior/sum(prior))
lprior[lprior==-Inf] <- -2.14748e+09
post_prior <- matrix(1,nrow(response),2^ncol(Q))
post <- Iterate(est,eta,lprior,post_prior,response,Q)
lprior
lprior[,rep(1,N)]
N=1000
lprior[,rep(1,N)]
###############################################################################
# Main_function_Validation:                                                   #
#                                                                             #
# This is the main function which refins Q matrix using Jimmy's sequential    #
# search                                                                      #
#                                                                             #
###############################################################################
rm(list=ls(all=TRUE))
path  <- '/Users/Aurora/Dropbox/CD/Sequetial Search'
#path <- 'D:/dropbox/CD/Sequetial Search'
Q        <- read.table(file=paste(path,'/Q_matrix_5.txt',sep='')) # original Q matrix
response <- read.table(file=paste(path,'/examinee_data.dat',sep=''))
eps <- .002
source(paste(path,'//sourceDir.R',sep=''))
sourceDir(paste(path,'/functions',sep=''))
alpha <- AlphaPermute(ncol(Q))
eta   <- Alphaeta(alpha,Q)
prior  <- matrix(1,2^ncol(Q),1)/2^ncol(Q)
lprior <- log(prior/sum(prior))
lprior[lprior==-Inf] <- -2.14748e+09
post_prior <- matrix(1,nrow(response),2^ncol(Q))
J <- nrow(Q)
K <- ncol(Q)
it <- 0;
diff <- 1;
maxit <- 999
crit <- .001
est <- -1*matrix(1,nrow(Q),2^max(rowSums(Q)))
for (j in 1:J) {
Kj <- rowSums(Q[j,])
est[j,1:2^Kj] <- .2
est[j,2^Kj] <- .8
}
post <- Findpost(est,eta,lprior,post_prior,response,Q)
lprior <- log(apply(post,2,mean))
lprior
source('~/Dropbox/CD/Sequetial Search/Main_Function_Validation.R')
post
Qrefine <- Sequential(eps,post,Q,response)
Qrefine
prior  <- matrix(1,2^ncol(Q),1)/2^ncol(Q)
lprior <- log(prior/sum(prior))
lprior[lprior==-Inf] <- -2.14748e+09
lprior
post_prior <- matrix(1,nrow(response),2^ncol(Q))
J <- nrow(Q)
K <- ncol(Q)
it <- 0;
diff <- 1;
maxit <- 999
crit <- .001
est <- -1*matrix(1,nrow(Q),2^max(rowSums(Q)))
for (j in 1:J) {
Kj <- rowSums(Q[j,])
est[j,1:2^Kj] <- .2
est[j,2^Kj] <- .8
}
post <- Findpost(est,eta,lprior,post_prior,response,Q)
cat(it,', ')
est0 <- est
for (j in 1:J) {
Kj <- sum(Q[j,])
Lj <- which(Q[j,]==1)
Qj <- c()
for (kj in 1:Kj) {
tmpQ <- c()
base <- rbind(matrix(0,2^(Kj-kj),1),matrix(1,2^(Kj-kj),1))
for (lj in 1:2^(kj-1)) {
tmpQ <- rbind(tmpQ,base)
}
Qj <- cbind(Qj,tmpQ)
}
Qj <- cbind(Qj,rowSums(Qj))
tmpq <- matrix(0,2^Kj,1)
for (k in 1:Kj) {
tmpq <- tmpq - 10^(Kj-k)*Qj[,k]
}
Qj <- cbind(Qj,tmpq)
Qj <- Qj[order(Qj[,Kj+1],Qj[,Kj+2]),]
Qj <- Qj[,1:Kj]
Qj <- as.matrix(Qj)
tmp_alpha <- alpha[,Lj]
for (kj in 1:2^Kj) {
tmp <- (matrix(1,2^K,1)%*%Qj[kj,] == tmp_alpha)*1
tmp_loc <- which(apply(tmp,1,prod)==1)
if (length(tmp_loc) == 1) {
tmp <- post[,tmp_loc]
} else {
tmp <- rowSums(post[,tmp_loc])
}
n1 <- sum(tmp)
r1 <- sum(response[,j]*tmp)
if (log(n1) < -2.14748e+09) {
n1 <- .0001
}
tmp_est <- r1/n1
if (tmp_est < 10^(-4)) {
tmp_est <- 10^(-4)
}
if (tmp_est > 1-10^(-4)) {
tmp_est <- 1-10^(-4)
}
est[j,kj] <- tmp_est
}
}
diff <- max(sqrt((est0-est)^2))
it <- it + 1
lprior
post0 <- Findpost(est,eta,lprior,post,response,Q) ###
post <- post0
lprior <- log(apply(post,2,mean))
lprior
lprior[lprior==-Inf] <- -2.14748e+09
lprior[lprior==NaN] <- -2.14748e+09
K <- ncol(Q)
N <- nrow(response)
J <- nrow(Q)
tmp0 <- matrix(0,2^K,J)
for (j in 1:J) {
for (cl in 1:2^K) {
tmp0[cl,j] <- est[j,eta[cl,j]+1]
}
}
lprior[,rep(1,N)
]
lprior
lprior <- t(log(apply(post,2,mean)))
lprior
dim(lprior)
lprior <- as.matrix(log(apply(post,2,mean)))
lprior
source('~/.active-rstudio-document')
post <- Iterate(est,eta,lprior,post_prior,response,Q)
source('~/Dropbox/CD/Sequetial Search/Main_Function_Validation.R')
Qrefine
Qrefine[,]
Qrefine[1,]
Qrefine[,]
Qrefine[,1]
Qrefine[1,]
#cat('\014')
Qrefine <- Sequential(eps,post,Q,response)
cat('Refined Q Matrix')
print(Qrefine)
source('~/.active-rstudio-document')
source('~/Dropbox/CD/Sequetial Search/Main_Function_Validation.R')
print(proc.time()-pmt)
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
source('~/Dropbox/CD/Sequetial Search/Main_Function_Validation.R')
source('~/Dropbox/CD/Sequetial Search/Main_Function_Validation.R')
source('~/Dropbox/CD/Sequetial Search/Main_Function_Validation.R')
source('~/Dropbox/CD/Sequetial Search/Main_Function_Validation.R')
source('~/Dropbox/CD/Sequetial Search/Main_Function_Validation.R')
Qrefine
cbind(Qrefine[,1],Qrefine[,2])
names(Qrefine)[1] <- 'A1'
print(Qrefine)
source('~/.active-rstudio-document')
source('~/Dropbox/Sequetial Search/functions/ParMLE.R')
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
estimate_ml
estimate_ML
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
dim(response)
s
s_real
g_real
View(response)
dim(response)
View(response)
View(response)
View(response)
save.image("~/Desktop/response.RData")
View(response)
View(response)
r=read.table(file='/Users/Aurora/Desktop/response.txt')
r=read.table(file='/Users/Aurora/Desktop/response.txt')
r=read.table(file='Users/Aurora/Desktop/response.txt')
r=read.table(file='/Users/Aurora/Desktop/response.txt')
r=read.table(file='/Users/Aurora/Desktop/response.txt')
View(r)
dim(r)
source('~/Dropbox/Sequetial Search/Main_Function_Simulation.R')
estimate_ML$sli
estimate_ML$sli
estimate_ML$slip
estimate_ML <- ParMLE(response, Q, alpha, model="DINA")
estimate_ML$sl
estimate_ML
s_real-estimate_ML$slip
source('~/Dropbox/Sequetial Search/Main_Function_Simulation.R')
estimate_EM$s_estimate)
estimate_EM$s_estimate
estimate_ML$slip
